summary(train_fit)
pk_train <- parkinsons[1:bound, 1:]
pk_train <- parkinsons[1:bound, 2:24]
train_fit <- lm(status ~ . , data=pk_train)
summary(train_fit)
pk_test <- parkinsons[(bound+1):nrow(parkinsons), 2:24]
pk_train <- parkinsons[1:bound, 2:24]
mean(((pk_train$status-predict(train_fit, pk_train))$status)^2)
mean(((pk_train$status-predict(train_fit, pk_train)))^2)
mean(((pk_test$status-predict(train_fit, pk_test)))^2)
plot(pk_train$status, predict(train_fit, pk_train) )
residuals(train_fit)
plot(residuals(train_fit))
mean(abs(pk_train$status-predict(train_fit)))
mean(abs(pk_train$status-predict(train_fit, pk_train)))
mean(abs(pk_test$status-predict(train_fit, pk_test)))
train_lda <- lda(status ~ ., data=pk_train)
library(MASS)
train_lda <- lda(status ~ ., data=pk_train)
mean(pk_train$status)
?scale
data=read.csv("~/Downloads/parkinsons.data", header=TRUE)
data = as.matrix(data[,-1])
set.seed(3041993)
data = data[sample(nrow(data)),]
### status is 0 for healthy , 1 for Parkinsons
status = data[,"status"]
### remove status column from data
data = data[, -which(colnames(data)=="status") ]
dataHealthy = data[status==0,]
dataParks = data[status==1,]
nHealthy = nrow(dataHealthy)
nParks = nrow(dataParks)
data[1:2,]
trainf = 0.8
Xtrain = rbind(dataHealthy[1:floor( trainf *nHealthy ),],
dataParks [1:floor ( trainf *nParks ),])
Ttrain = matrix(c(rep(1,floor( trainf*nHealthy)),rep(2, floor ( trainf *nParks))))
Xtest = rbind(dataHealthy[-(1:floor(trainf*nHealthy )),],
dataParks[-(1:floor ( trainf *nParks )),])
Ttest = matrix(c(rep(1,nHealthy-floor(trainf*nHealthy)),
rep(2,nParks-floor( trainf *nParks))))
Xtrain
str(Ttrain)
Xtrain1 = cbind(1,scale(Xtrain))
Xtrain1
?cbind
w = solve(t(Xtrain1)%*%Xtrain1,t(Xtrain1)%*%Ttrain)
w
?solve
pCorrectTrain = sum(apply(abs(cbind(TtrainPredicted-1, TtrainPredicted-2)),
1, which.min) == Ttrain) / length(Ttrain) * 100.0
Xtrain1 = cbind(1,scale(Xtrain))
#CALCULATE W (COEFFS FOR LS REGRESSION)
w = solve(t(Xtrain1)%*%Xtrain1,t(Xtrain1)%*%Ttrain)
#Test
TtrainPredicted = Xtrain1 %*% w
TtestPredicted = cbind(1,scale(Xtest)) %*% w
pCorrectTrain = sum(apply(abs(cbind(TtrainPredicted-1, TtrainPredicted-2)),
1, which.min) == Ttrain) / length(Ttrain) * 100.0
pCorrectTrain
p=par(mfrow=c(1,2),bty="n")
matplot(cbind(Ttrain, TtrainPredicted ), type="b",pch=1,lty=1,
xlab="Sample",ylab="True and Predicted Class",main="Train Data")
matplot(cbind(Ttest,TtestPredicted ), type="b",pch=1,lty=1,
xlab="Sample",ylab="True and Predicted Class",main="Test Data")
Xtrains = scale(Xtrain)
Xtests = scale(Xtest)
mean1 = colMeans(Xtrains[Ttrain==1,])
mean1
cov1 = cov(Xtrains[Ttrain==1,])
cov1
mean2 = colMeans(Xtrains[Ttrain==2,])
cov2 = cov(Xtrains[Ttrain==2,])
covavg = cov1 * nHealthy/N + cov2 * nParks/N
N = nHealthy + nParks
covavg = cov1 * nHealthy/N + cov2 * nParks/N
covavg
l1 <- list("note",1,'the',2,"different",c(3,4),'types')
l1
circle_area <- function(radius = 1){
if radius < 0 {
stop()
}
area <- pi*radius^2
return(area)
}
circle_area <- function(radius = 1){
if (radius<0) {
stop()
}
area <- pi*radius^2
return(area)
}
pi
circle_area(3)
circle_area()
circle_area(radius = 3)
circle_area(radius = -2)
cyl_area <- function(radius=1, height=1) {
if (height < 0) {
stop()
}
area = circle_area(radius)*height
}
cyl_area()
cyl_area(radius = 2, height = 3)
cyl_area(radius = -2, height = 1)
cyl_area(radius = 2, height = -1)
cyl_area(radius = -2, height = -1)
cyl_volume()
cyl_volume(radius = 3, height = 10)
cyl_volume(height = 10, radius = 3)
# your cyl_volume() function
cyl_volume <- function(radius=1, height=1) {
if (height < 0) { # negative radius will be caught by circle_area
stop()
}
vol = circle_area(radius)*height
return(vol)
}
cyl_volume()
cyl_volume(radius = 3, height = 10)
cyl_volume(height = 10, radius = 3)
x <- c(
dollar = 1,
euro = 0.89,
pound = 0.77,
yen = 101.69,
yuan = 6.67,
won = 1118.21,
rupee = 66.98,
peso = 19.82,
real = 3.25)
x['dollar']
exchange <- function(amount = 1, from = "dollar", to = "euro") {
# vector of dollar exchange rates
x <- c(
dollar = 1,
euro = 0.89,
pound = 0.77,
yen = 101.69,
yuan = 6.67,
won = 1118.21,
rupee = 66.98,
peso = 19.82,
real = 3.25)
# write the rest of the code of your function
# ...
in_dollars <- amount/x[from]
result <- in_dollars*x[to]
return(result)
}
x['dollar']
exchange
exchange()
exchange(from=euro, to=euro)
exchange(from='euro', to='euro')
exchange()
exchange(amount = 10, from = 'euro', to = 'peso')
exchange(amount = 20, from = 'yuan', to = 'pound')
exchange(amount = 30, from = 'rupee', to = 'won')
p1 <- c(0, 0)
p1[1]
p1 <- c(0, 1)
p1[1]
find_distance <- function(p1, p2){
dist <- sqrt((p1[1] - p2[1])^2  + (p1[2] - p2[2])^2 )
return(dist)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
find_distance(p1, p2)
find_midpoint <- function(p1, p2) {
p = c((p1[1] + p2[1])/2, (p1[2] + p2[2])/2)
return(p)
}
p1 <- c(1, 10)
p2 <- c(10, 20)
find_midpoint(p1, p2)
p1
# your find_slope() function
b = \frac{y_2 - y_1}{x_2 - x_1}, \quad a = y_1 - b x_1
find_slope <- function(p1, p2) {
slope = (p1[2]-p2[2])/(p1[1] - p2[1])
return(slope)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
find_slope(p1, p2)
# your find_intercept() function
find_intercept <- function(p1, p2) {
slope = find_slope(p1, p2)
intercept = p1[2] + slope*p1[1]
return(intercept)
}
# your find_line() function
eq <- function(p1, p2) {
slope <- find_slope(p1, p2)
intercept <- find_intercept(p1, p2)
vec <- c(intercept, slope)
names(vec) <- c("intercept", "slope")
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
find_line <- function(p1, p2) {
slope <- find_slope(p1, p2)
intercept <- find_intercept(p1, p2)
vec <- c(intercept, slope)
names(vec) <- c("intercept", "slope")
}
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
# your find_line() function
find_line <- function(p1, p2) {
slope <- find_slope(p1, p2)
intercept <- find_intercept(p1, p2)
vec <- c("intercept" = intercept, "slope" = slope)
#names(vec) <- c("intercept", "slope")
return(vec)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
vec <- c(intercept, slope)
# your find_line() function
find_line <- function(p1, p2) {
slope <- find_slope(p1, p2)
intercept <- find_intercept(p1, p2)
#vec <- c("intercept" = intercept, "slope" = slope)
vec <- c(intercept, slope)
names(vec) <- c("intercept", "slope")
return(vec)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
# your find_line() function
find_line <- function(p1, p2) {
s <- find_slope(p1, p2)
i <- find_intercept(p1, p2)
vec <- list(intercept = c(i), "slope" = c(s))
#vec <- c(intercept, slope)
#names(vec) <- c("intercept", "slope")
return(vec)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
?stop
# your cyl_area() function
cyl_area <- function(radius=1, height=1) {
if (height < 0) { # negative radius will be caught by circle_area
stop()
}
else {
area = 2*pi*radius*height + 2*circle_area(radius)
return(area)
}
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
# your find_line() function
find_line <- function(p1, p2) {
s <- find_slope(p1, p2)
i <- find_intercept(p1, p2)
vec <- list("intercept"" = c(i), "slope" = c(s))
return(vec)
}
# your find_line() function
find_line <- function(p1, p2) {
s <- find_slope(p1, p2)
i <- find_intercept(p1, p2)
vec <- list("intercept" = c(i), "slope" = c(s))
return(vec)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
eq <- find_line(p1, p2)
eq$intercept
eq$slope
# your info_points() function
info_points <- function(p1, p2) {
d = find_distance(p1, p2)
m = find_midpoint(p1, p2)
i = find_intercept(p1, p2)
s = find_slope(p1, p2)
results = ("distance"=c(d), "midpoint" = c(m), "intercept" = c(i), "slope" = c(s) )
}
# your info_points() function
info_points <- function(p1, p2) {
d = find_distance(p1, p2)
m = find_midpoint(p1, p2)
i = find_intercept(p1, p2)
s = find_slope(p1, p2)
results = list("distance"=c(d), "midpoint" = c(m), "intercept" = c(i), "slope" = c(s))
return(results)
}
# NOTE: Uncomment the following lines and then knit this file to check your function is working as required
p1 <- c(1, 10)
p2 <- c(10, 20)
results <- info_points(p1, p2)
results$distance
results$midpoint
results$intercept
results$slope
# change these points and pass them to info_points()
p1 <- c(-2, 4)
p2 <- c(1, 2)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(-1/2, 3, cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = 8/3, b = -2/3, col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', (-2/3) * x, ' + ', (8/3))))
# change these points and pass them to info_points()
p1 <- c(-3, 1)
p2 <- c(1, 4)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(-1/2, 3, cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = 8/3, b = -2/3, col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', (-2/3) * x, ' + ', (8/3))))
# change these points and pass them to info_points()
p1 <- c(-3, 1)
p2 <- c(1, 4)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(-1/2, 3, cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = find_slope(p1, p2), b = find_intercept(p1, p2), col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', find_slope(p1, p2) * x, ' + ', (find_intercept(p1, p2)))))
title(main = expression(paste(y, ' = ', (find_slope(p1, p2)) * x, ' + ', (find_intercept(p1, p2)) )))
# change these points and pass them to info_points()
p1 <- c(-3, 1)
p2 <- c(1, 4)
results <- info_points(p1, p2)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = results$slope, b = results$intercept, col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', (results$slope) * x, ' + ', (results$intercept) )))
# change these points and pass them to info_points()
p1 <- c(-3, 1)
p2 <- c(1, 4)
results <- info_points(p1, p2)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = results$slope, b = results$intercept, col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', toString(results$slope) * x, ' + ',  toString(results$intercept) )))
p1 <- c(-3, 1)
p2 <- c(1, 4)
results <- info_points(p1, p2)
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
abline(a = results$slope, b = results$intercept, col = "#FF883477", lwd = 3)
plot.new()
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = results$slope, b = results$intercept, col = "#FF883477", lwd = 3)
results <- info_points(p1, p2)
abline(a = results$slope, b = results$intercept, col = "#FF883477", lwd = 3)
results$intercept
title(main = expression(paste(y, ' = ', toString(results$slope) * x, ' + ',  toString(results$intercept) )))
results$slope
plot.new()
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = 0.75, b = -1.25, col = "#FF883477", lwd = 3)
title(main = expression(paste(y, ' = ', toString(results$slope) * x, ' + ',  toString(results$intercept) )))
abline(a = 0.75, b = -1.25, col = "#FF883477")
plot.new()
# depending on your chosen points you may have to set different limits
plot.window(xlim = c(-3, 3), ylim = c(0, 5))
axis(side = 1)
axis(side = 2, las = 1)
points(p1[1], p1[2], cex = 1.5, col = "#FF8834", pch = 19)
points(p2[1], p2[2], cex = 1.5, col = "#FF8834", pch = 19)
# midpoint (here you should use the midpoint outputs of your function)
points(results$midpoint[1], results$midpoint[2], cex = 1.5, pch = "x", col = "#E16868")
# slope and intercept (here you should use the outputs of your function)
abline(a = 0.75, b = -1.25, col = "#FF883477")
abline(a = -1.25, b = 0.75, col = "#FF883477")
abline(a = 1, b = 0.75, col = "#FF883477")
dat <- read.csv('Advertising.csv', row.names = 1)
dat <- read.csv('Advertising.csv', row.names = 1)
ls()
getwd()
setwd("/Users/Abigail/lab_simple_regression")
setwd("/Users/Abigail/lab_simple_regression")
dat <- read.csv('Advertising.csv', row.names = 1)
dat <- read.csv('Advertising.csv', row.names = 1)
setwd("/Users/Abigail/lab_simple_regression")
dat <- read.csv('../data/Advertising.csv', row.names = 1)
setwd("Users/Abigail/Documents/stat159-fall2016-hw02/code")
getwd()
setwd("Users/Abigail/Documents")
getwd()
setwd()
setwd("/Users/Abigail")
setwd("/Users/Abigail/Documents/")
setwd("Users/Abigail/Documents/stat159-fall2016-hw02/code/")
setwd()
getwd()
setwd("/Users/Abigail/Documents/stat159-fall2016-hw02/")
setwd("/Users/Abigail/Documents/stat159-fall2016-hw02/code")
ls
dat <- read.csv('../data/Advertising.csv', row.names = 1)
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
dev.off
dev.off()
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
dev.off()
dev.off()
dev.off
sink("../data/eda-output.txt")
summary(data)
sink()
dev.off()
dev.off
dev.off()
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
dev.off()
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main = "TV Histogram", xlab = "Dollars spent", col = "light blue", border = "white")
dev.off()
pdf("../images/histogram-tv.pdf")
hist(dat$TV, main= "TV Histogram")
dev.off()
pdf("../images/histogram-tv.pdf")
dev.list()
